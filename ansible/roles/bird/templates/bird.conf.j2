log syslog all;
router id {{ (ansible_all_ipv4_addresses | ansible.netcommon.ipaddr(network_facts.control_plane_prefix) | list)[0] }};

protocol device {
  scan time 10;
};

protocol direct {
  ipv4;
  ipv6;
};

protocol kernel kernel_v4 {
  ipv4 {
    export filter { # Exported to FIB (Kernel routing table)
      if proto = "direct1" then reject;
      accept;
    };
  };
  learn;
};

protocol kernel kernel_v6 {
  ipv6 {
    export filter { # Exported to FIB (Kernel routing table)
      if proto = "direct1" then reject;
      accept;
    };
  };
  learn;
};


# The following configuration abuses igp table to accept routes having any NEXT_HOP address 
#  then rewrites NEXT_HOP by an import filter. 
# The import filter carefully does not rewrite NEXT_HOP address if the address is directly reachable.

# A dummy IGP routing table with a default gateway to accept any `NEXT_HOP`.
ipv4 table dummytab;
protocol static dummystatic {
    ipv4 { table dummytab; };
    route 0.0.0.0/0 via "lo";
}


template bgp internal_bgp {
  password "{{ ibgp_passwd }}";
  startup hold time 0;
  graceful restart on;
  advertise hostname;
  setkey on;
  bfd on;
  ipv4 {
    igp table dummytab;
    gateway recursive;
    export filter {
      # Reject inet default-routes
      if net = 0.0.0.0/0 then reject;
      if net = ::0/0 then reject;
      accept;
    };
    import filter {
      # Reject inet default-routes
      if net = 0.0.0.0/0 then reject;
      if net = ::0/0 then reject;
      
      # if the NEXT_HOP address is in the same subnet of the sending router, use NEXT_HOP as is. 
      if bgp_next_hop = from then {
        gw = bgp_next_hop;
        accept;
      }
      
      # otherwise, rewrite NEXT_HOP ("gw") to the address of the sending router ("from")
      gw = from;
      accept;
    };
  };
};

{#
TODO: Add support for IPv6
  - Check hostname is underscored
#}
{% for peer in ibgp_peers %}
protocol bgp {{ peer.name | replace('-','_') }} from internal_bgp {
  local {{ (ansible_all_ipv4_addresses | ansible.netcommon.ipaddr(network_facts.control_plane_prefix) | list)[0] }} as {{ibgp_asn}};
  neighbor {{ peer.ip4_cidr_address | ansible.netcommon.ipv4('address') }} as {{ibgp_asn}};
{% if peer.password is defined %}
  "{{ peer.password }}";
{% endif %}
{% if not (peer.bfd | default(true)) %}
  bfd off;
{% endif %}
{% if (peer.rr_client | default(false)) %}
  rr client;
{% endif %}
{% if (peer.multi_hop | default(false)) %}
  multihop;
{% endif %}
};

{%endfor%}
protocol bfd {
    interface "*" {
        min rx interval 100 ms;
        min tx interval 100 ms;
        idle tx interval 300 ms;
        multiplier 10;
        password "{{ibgp_passwd}}";
    };

{% for peer in ibgp_peers %}
{%  if (peer.bfd | default(true)) %}
    neighbor {{ peer.ip4_cidr_address | ansible.netcommon.ipv4('address') }};
{%  endif %}
{%endfor%}
};
